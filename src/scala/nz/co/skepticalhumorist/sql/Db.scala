// $Id$
// John Hurst (jbhurst@attglobal.net)
// 2009-01-06

package nz.co.skepticalhumorist.sql

import scala.collection.mutable.ListBuffer
import java.sql._
import javax.sql._
import java.util.Properties

// This Scala class is based on the Groovy standard library groovy.sql.Sql class.
// Primary constructor with both DataSource and Connection is private: use auxiliary constructors.
class Db private (
  val dataSource: DataSource,
  val connection: Connection
) {

  // Auxiliary constructors for DataSource or Connection.
  def this(dataSource: DataSource) = this(dataSource, null)
  def this(connection: Connection) = this(null, connection)

  def call(sql: String, params: AnyRef*) = {
    // JH_TODO
  }

  def callResultSet(sql: String, params: AnyRef*)(f: ResultSet => Unit) = {
    // JH_TODO
  }

  def close = {
    if (connection != null) {
      connection.close
    }
  }

  def commit = {
    if (connection != null) {
      connection.close
    }
  }

  def rollback() {
    if (connection != null) {
      connection.rollback
    }
  }

  def execute(sql: String, params: AnyRef*): Boolean = {
    prepareAndExecuteStatement(sql, params: _*) {_.execute}
  }

//  // JH_TODO: autogenerated keys.  But I don't think this is supported by Oracle.  Apache Derby or HSQLDB?
//  def executeInsert(sql: String, params: AnyRef*): List[Seq[AnyRef]] = {
//    List()
//  }

  def executeUpdate(sql: String, params: AnyRef*): Int = {
    prepareAndExecuteStatement(sql, params: _*) {_.executeUpdate()}
  }

  private def nopMeta(meta: ResultSetMetaData) {
    // do nothing
  }

  def firstRow(sql: String, params: AnyRef*) : Option[Seq[AnyRef]] = {
    queryFirst(sql, params: _*)(resultsToSeqRow)
  }

  def rows(sql: String, params: AnyRef*): List[Seq[AnyRef]] = {
    queryList(sql, params: _*)(resultsToSeqRow)
  }

  private def resultsToSeqRow(resultSet: ResultSet): Seq[AnyRef] = {
    // JH_TODO: I can't get the simpler "yield" version below to work.
    // The problem is that for/yield returns a functional/proxy Seq, not the real Seq.
    // The elements in the Seq are not fully evaluated until they are dereferenced --
    // that doesn't work here because the ResultSet is closed by then.
    // I wonder how we could force the for/yield to fully evaluate its loop.

//    for (i <- 0 until resultSet.getMetaData.getColumnCount)
//      yield resultSet.getObject(i + 1)

    val columnCount = resultSet.getMetaData.getColumnCount
    val result = new scala.Array[AnyRef](columnCount)
    for (i <- 0 until columnCount) {
      result(i) = resultSet.getObject(i + 1)
    }
    result
  }

  def queryForString(sql: String, params: AnyRef*): Option[String] = {
    queryFirst(sql, params: _*) {resultSet: ResultSet =>
      resultSet.getString(1)
    }
  }

  def queryForInt(sql: String, params: AnyRef*): Option[Int] = {
    queryFirst(sql, params: _*) {resultSet: ResultSet =>
      resultSet.getInt(1)
    }
  }

  def queryFirst[T](sql: String, params: AnyRef*)(f: ResultSet => T): Option[T] = {
    queryFirstMeta(sql, params: _*)(nopMeta)(f)
  }

  def queryFirstMeta[T](sql: String, params: AnyRef*)(meta: ResultSetMetaData => Unit)(f: ResultSet => T): Option[T] = {
    prepareAndExecuteStatement(sql, params: _*) {
      executeFirstWithResultSet(_)(meta) {
        f(_)
      }
    }
  }

  def query(sql: String, params: AnyRef*)(f: ResultSet => Unit) {
    queryMeta(sql, params: _*)(nopMeta)(f)
  }

  def queryMeta(sql: String, params: AnyRef*)(meta: ResultSetMetaData => Unit)(f: ResultSet => Unit) {
    prepareAndExecuteStatement(sql, params: _*) {
      executeWithResultSet(_)(meta) {
        f(_)
      }
    }
  }

  def queryList[T](sql: String, params: AnyRef*)(f: ResultSet => T): List[T] = {
    val result = new ListBuffer[T]
    query(sql, params: _*) {
      result += f(_)
    }
    result.toList
  }

  private def executeWithConnection[T](f: Connection => T): T = {
    val connection =
      if (dataSource != null) dataSource.getConnection else this.connection
    try {
      f(connection)
    }
    finally {
      if (dataSource != null) {
        connection.close
      }
    }
  }

  private def executeWithStatement[T](f: Statement => T): T = {
    executeWithConnection {connection =>
      val statement = connection.createStatement
      try {
        f(statement)
      }
      finally {
        statement.close
      }
    }
  }

  private def executeWithResultSet(preparedStatement: PreparedStatement)(meta: ResultSetMetaData => Unit)(f: ResultSet => Unit) {
    val resultSet = preparedStatement.executeQuery
    executeAndCloseResultSet(resultSet)(meta)(f)
  }

  private def executeAndCloseResultSet(resultSet: ResultSet)(meta: ResultSetMetaData => Unit)(f: ResultSet => Unit) {
    try {
      if (resultSet.next) {
        meta(resultSet.getMetaData)
        f(resultSet)
      }
      while (resultSet.next) {
        f(resultSet)
      }
    }
    finally {
      resultSet.close
    }
  }

  private def executeFirstWithResultSet[T](preparedStatement: PreparedStatement)(meta: ResultSetMetaData => Unit)(f: ResultSet => T): Option[T] = {
    val resultSet = preparedStatement.executeQuery
    executeFirstAndCloseResultSet(resultSet)(meta)(f)
  }

  private def executeFirstAndCloseResultSet[T](resultSet: ResultSet)(meta: ResultSetMetaData => Unit)(f: ResultSet => T): Option[T] = {
    try {
      if (resultSet.next) {
        meta(resultSet.getMetaData)
        Some(f(resultSet))
      }
      else {
        None
      }
    }
    finally {
      resultSet.close
    }
  }

  private def prepareAndExecuteStatement[T](sql: String, params: AnyRef*)(f: PreparedStatement => T): T = {
    executeWithConnection {connection =>
      val statement = connection.prepareStatement(sql)
      try {
        for (i <- 0 until params.length) {
          statement.setObject(i + 1, params(i))
        }
        f(statement)
      }
      finally {
        statement.close
      }
    }
  }
}

object Db {
  private def loadDriverClass(driverClassName: String) {
    Class.forName(driverClassName)
  }

  def apply(url: String): Db = {
    new Db(DriverManager.getConnection(url))
  }
  def apply(url: String, properties: Properties): Db = {
    new Db(DriverManager.getConnection(url, properties))
  }
  def apply(url: String, props: Properties, driverClassName: String): Db = {
    loadDriverClass(driverClassName)
    apply(url, props)
  }
  def apply(url: String, driverClassName: String): Db = {
    loadDriverClass(driverClassName)
    apply(url)
  }
  def apply(url: String, user: String, password: String): Db = {
    new Db(DriverManager.getConnection(url, user, password))
  }
  def apply(url: String, user: String, password: String, driverClassName: String): Db = {
    loadDriverClass(driverClassName)
    new Db(DriverManager.getConnection(url, user, password))
  }
}
